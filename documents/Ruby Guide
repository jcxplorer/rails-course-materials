title. Ruby

TODO: Document "==" and "!="
TODO: Document ranges ".." and "..."


h1. Overview

Ruby is an object-orientated language first released in 1995 by Yukihiro Matsumoto ("Matz"). Ruby comes preinstalled on Mac OS X and on most major Linux distributions.  It is also possible to install Ruby in a Microsoft Windows environment. The Ruby language takes fetures and influences from such languages as Perl, Smalltalk, Eiffel, Ada, Lisp, and Python.


h2. Object Orientated

Ruby goes to great lengths to be a purely object oriented language. Every value in Ruby is an object, even the most primitive things: strings, numbers and even true and false. Every object has a class and every class has one superclass. At the root of the class hiearchy is the class Object, from which all other classes inherit.

Every class has a set of methods which can be called on objects of that class. Methods are always called on an object - there are no "class methods", as there are in many other languages (though Ruby does a great job of faking them).

Every object has a set of instance variables which hold the state of the object. Instance variables are created and accessed from within methods called on the object. Instance variables are completely private to an object. No other object can see them, not even other objects of the same class, or the class itself. All communication between Ruby objects happens through methods.


h2. Mixins

In addition to classes, Ruby has modules. A module has methods, just like a class, but it has no instances. Instead, a module can be included, or "mixed in", to a class, which adds the methods of that module to the class. This is very much like inheritance but far more flexible because a class can include many different modules. By building individual features into separate modules, functionality can be combined in elaborate ways and code easily reused. Mix-ins help keep Ruby code free of complicated and restrictive class hiearchies.


h2. Dynamic

Ruby is a very dynamic programming language. Ruby programs aren't compiled, in the way that C or Java programs are. All of the class, module and method definitions in a program are built by the code when it is run. A program can also modify its own definitions while it's running (commonly known as "monkey patching"). Even the most primitive classes of the language like String and Integer can be opened up and extended.

Variables in Ruby are dynamically typed, which means that any variable can hold any type of object. When you call a method on an object, Ruby looks up the method by name alone - it doesn't care about the type of the object. This is called duck typing and it lets you make classes that can pretend to be other classes, just by implementing the same methods.


h2. Variables and scope

You do not need to declare variables or variable scope in Ruby. The name of the variable automatically determines its scope.

    * x is local variable (or something besides a variable)
    * $x is a global variable
    * @x is an instance variable
    * @@x is a class variable


h2. Blocks

Blocks are one of Ruby's most unique and most loved features. A block is a piece of code that can appear after a call to a method, like this:

<code>
cities.each do |city|
  city.upcase!
end
</code>

The block is everything between the do and the end. The code in the block is not evaluated right away, rather it is packaged into an object and passed to the each method as an argument. That object can be called at any time, just like calling a method. The each method calls the block whenever it needs to iterate through the array. The block gives you a lot of control over how sort behaves. A block object, like any other object, can be stored in a variable, passed along to other methods, or even copied.

Many programming languages support code objects like this. They're called closures and they are a very powerful feature in any language, but they are typically underused because the code to create them tends to look ugly and unnatural. A Ruby block is simply a special, clean syntax for the common case of creating a closure and passing it to a method. This simple feature has inspired Rubyists to use closures extensively, in all sorts of creative new ways.


h1. Ruby Editors

Ruby can be edited in almost any text editor and there are a number of (mostly) proprietary IDEs available for development in Ruby and Ruby on Rails.

Some examples of editors and IDEs:

* Komodo Edit
* Vim
* TextMate
* NetBeans
* Aptana Studio


h1. Basic of Ruby

h2. Irb

Irb (Interactive Ruby) is an interactive interface to Ruby which is mostly useful for testing small snippets of code.  Using Irb will save you from having to write lots of small text files when you are testing a feature or trying to see if a particular function will work.

You can also find an online version of Irb at http://tryruby.sophrinix.com/


h2. Datatypes

As mentioned earlier, everything in Ruby is an object. As a way of testing this try the following in Irb:

<code>
123.class
999999999999999999999999999999999999999999999.class
nil.class
true.class
"hello world".class
:symbol.class
</code>

h3. Constants

There are only two basic thing you need to remember about constants:

* Constants ALWAYS start with capital letters ('Constant' would be a constant, but 'constant' would not)
* You can change constant in Ruby, but you shouldn't (Ruby will give you a warning)


h3. Symbols

So did you notice something weird about that previous code listing? "What the hell was that colon thingy about?" Well, it just so happens that Ruby's object oriented ways have a cost: lots of objects make for slow code. Every time you type a string, Ruby makes a new object. Regardless of whether two strings are identical, Ruby treats every instance as a new object. You could have "live long and prosper" in your code once and then again later on and Ruby wouldn't even realize that they're pretty much the same thing. Here is a sample irb session which demonstrates this fact :

irb> "live long and prosper".object_id
=> -606662268
irb> "live long and prosper".object_id
=> -606666538

Notice that the object ID returned by irb Ruby is different even for the same two strings.

To get around this memory hoggishness, Ruby has provided "symbols." Symbols are lightweight objects best used for comparisons and internal logic. If the user doesn't ever see it, why not use a symbol rather than a string? Your code will thank you for it. Let us try running the above code using symbols instead of strings :

irb> :my_symbol.object_id
=> 150808
irb> :my_symbol.object_id
=> 150808

Symbols are denoted by the colon sitting out in front of them, like so: :symbol_name

Symbols are very commonly used for hash keys.


h3. Hashes

Hashes are like dictionaries, in a sense. You have a key, a reference, and you look it up to find the associated object, the definition.

The best way to illustrate this, I think, is simply to demonstrate:

<code>
hash = { :leia => "Princess from Alderaan", :han => "Rebel without a cause", :luke => "Farmboy turned Jedi" }
puts hash[:leia]
puts hash[:han]
puts hash[:luke]
</code>

This code will print out "Princess from Alderaan", "Rebel without a cause", and "Farmboy turned Jedi" in consecutive order.


h3. Arrays

Arrays are a lot like hashes, but the keys are always consecutive numbers. Also, the first key in an array is always 0. So in an array with 5 items, the last element would be found at array[4] and the first element would be found at array[0].

Using an out of range index will return nil.

<code>
array = ["This", "is", "an array"]
puts array[0] # => "This"
puts array[3] # => nil
</code>


h3. Strings

h4. String literals

One way to create a String is to use single or double quotes inside a Ruby program to create what is called a string literal.

puts 'Hello world'
puts "Hello world"

Being able to use either single or double quotes is similar to Perl, but different from languages such as C and Java, which use double quotes for string literals and single quotes for single characters.

So what difference is there between single quotes and double quotes in Ruby? In the above code, there's no difference. However, consider the following code:

puts "Betty's pie shop"
puts 'Betty\'s pie shop'

Because "Betty's" contains an apostrophe, which is the same character as the single quote, in the second line we need to use a backslash to escape the apostrophe so that Ruby understands that the apostrophe is in the string literal instead of marking the end of the string literal. The backslash followed by the single quote is called an escape sequence.


h4. Single quotes

Single quotes only support two escape sequences.

    * \' – single quote
    * \\ – single backslash

Except for these two escape sequences, everything else between single quotes is treated literally.


h4. Double quotes

Double quotes allow for many more escape sequences than single quotes. They also allow you to embed variables or Ruby code inside of a string literal – this is commonly referred to as interpolation.

<code>
name = "bob"
puts "Your name is #{name.capitalize}"
</code>


h4. Escape sequences

The following escape sequences can be used inside double quotes:

* \" – double quote
* \\ – single backslash
* \a – bell/alert
* \b – backspace
* \r – carriage return
* \n – newline
* \s – space
* \t – tab


h4. Very Long Strings

There are a few ways to use very long (multiple lines) Strings in Ruby.  Perhaps the simplest of these is:

s = %{My toast has flown from my hand                                         
And my toast has gone to the                                            
moon.                                                                   
But when I saw it on television,                                        
Planting our flag on Halley's                                           
comet,                                                                  
More still did I want to eat it.}

h3. Numbers (Integers and Floats)

The basic datatypes in Ruby are integers and floats.
 
The number operators in Ruby are pretty similar to operators in other modern languages:

* + addition
* - subtraction
* / division
* * multiplication
* ** exponent (e.g. 26**3 == 26³)
* % modulus (the remainder of two divided numbers)


h2. Classes and Objects


h2. Methods


h2. Comments

Comments are denoted using a hash character (#).

For example:
<code>
# this is a comment line
</code>

h2. Operators

h3. Assignment

Assignment in Ruby is done using the equal operator "=". This is both for variables and objects, but since strings, floats, and integers are actually objects in Ruby, you're always assigning objects.

Examples:

<code>
	colour = "red"
	other_colour = String.new("blue")
	number = 123	
</code>

h4. Self assignment

<code>
	x = 1           #=>1
	x += x          #=>2
	x -= x          #=>0
	x += 4          #=>x was 0 so x= + 4 # x is positive 4
	x *= x          #=>16
	x **= x         #=>18446744073709551616 # Raise to the power
	x /= x          #=>1
</code>

If you're used to C-type languages, you might be wondering where are the increment and decrement operators (++ and --), well in Ruby the closest equivalents are "x += 1" and "x -= 1".

h4. Multiple assignments

In Ruby you can assign values to multiple variables on one line:

<code>
	colour1, colour2, colour3 = "red", "blue", "green"
	colours, city = ["red", "blue", "green"], "Helsinki"
</code>

h4. Conditional assignment

The operator "||=" checks whether a variable is nil (or inexistent) and assigns an object to it if it is.

<code>
	configuration ||= "default value"
</code>

h2. Conditionals

Ruby can control the execution of code using conditional branches. A conditional branch takes the result of a test expression and executes a block of code depending whether the test expression is true or false. If the test expression evaluates to the constant false or nil, the test is false; otherwise, it is true. Note that the number zero is considered true, whereas many other programming languages consider it false.

h3. if

<code>
a = 5
if a == 4
  a = 7
end
print a # => 5
</code>

If the block executed as result of a test expression is only one line of code, you can write the if statement after the code. The previous example would become:

<code>
a = 5
a = 7 if a == 4
print a
</code>

h3. unless

The unless-expression is the opposite of the if-expression, the code-block it contains will only be executed if the test expression is false.

<code>
my_city = "Helsinki"
unless my_city == "Helsinki"
	print "I don't live in Helsinki"
end
</code>

As with the short if-statement shown before, the previous example could be written using only two lines of code:

<code>
my_city = "Helsinki"
print "I don't live in Helsinki" unless my_city == "Helsinki"
</code>

h3. case

The case expressions is very useful when testing the same variable multiple times.

FIXME: Write an example that makes sense
<code>
	age = 25
	case age
		when 0..18
			puts "Underaged"
		when 18..65
			puts "Working age"
		when 65..120
			puts "Retired"
		else
			puts "Probably deceased"
		end
</code>

h2. Loops

h3. while

h3. until

h3. for

h3. break